
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Roleplay Assistant</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
:root {
  --bg-primary: #0a0a0a; --bg-secondary: #141414; --bg-tertiary: #1a1a1a;
  --text-primary: #ffffff; --text-secondary: #a0a0a0; --accent: #6366f1;
  --accent-hover: #4f46e5; --user-bubble: #262626; --border: rgba(255, 255, 255, 0.1);
  --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3); --danger: #ef4444;
}
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  background: var(--bg-primary); color: var(--text-primary);
  height: 100vh; display: flex; overflow: hidden;
}
.container { display: flex; width: 100%; height: 100%; transition: padding 0.3s ease-in-out; }
.main-panel {
  flex: 1; display: flex; flex-direction: column; background: var(--bg-secondary);
  border-radius: 12px; margin: 12px; overflow: hidden; min-width: 0;
}
.chat-header {
  background: var(--bg-tertiary); padding: 20px; border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
}
.chat-header h1 { font-size: 1.25rem; font-weight: 600; }
.status { display: flex; align-items: center; gap: 8px; font-size: 0.875rem; color: var(--text-secondary); }
.status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--danger); }
.status-dot.connected { background: #10b981; }
.status-dot.generating { background: #f59e0b; animation: pulse 1.5s ease-in-out infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
.chat-messages {
  flex: 1; overflow-y: auto; padding: 24px; display: flex; flex-direction: column; gap: 16px;
}
.chat-messages::-webkit-scrollbar { width: 8px; }
.chat-messages::-webkit-scrollbar-track { background: transparent; }
.chat-messages::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.1); border-radius: 4px; }
.message { display: flex; flex-direction: column; gap: 4px; max-width: 80%; animation: fadeIn 0.3s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
/* ZMIANA: Dodano align-items, aby dymki nie rozciƒÖga≈Çy siƒô na ca≈ÇƒÖ szeroko≈õƒá */
.message { display: flex; flex-direction: column; gap: 4px; max-width: 80%; animation: fadeIn 0.3s ease-in; }
.message.user { align-self: flex-end; align-items: flex-end; } 
.message.assistant { align-self: flex-start; align-items: flex-start; }
.message.system { align-self: center; align-items: center; max-width: 90%; opacity: 0.7; }

/* ZMIANA: Usuniƒôto width: 100% i dodano min-width: 0 */
.message-body { display: flex; flex-direction: column; min-width: 0; }
.message-content {
    font-size: 0.95rem; line-height: 1.5; white-space: pre-wrap; word-break: break-word;
    position: relative; overflow-wrap: anywhere; padding: 4px 0;
}
.message-content em, .thought-container em, .stats-container em, .final-thoughts-container em {
  color: rgba(255, 255, 255, 0.7);
}
.message.user .message-body { background: var(--user-bubble); padding: 10px 15px; border-radius: 18px; text-align: left; }
.message.system .message-body {
  background: rgba(255,255,255,0.05); border: 1px solid var(--border); text-align: left;
  font-size: 0.875rem; color: var(--text-secondary); padding: 12px 18px; border-radius: 18px;
  white-space: pre-wrap;
}
.thought-container {
  font-size: 0.85em; color: var(--text-secondary); white-space: pre-wrap; word-break: break-word; font-family: monospace;
  border-bottom: 1px solid var(--border); padding: 8px 12px 10px; margin-bottom: 6px;
  cursor: pointer; transition: max-height 0.25s ease-in-out; position: relative;
  background: var(--bg-secondary);
  scrollbar-width: none;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.thought-container::-webkit-scrollbar { display: none; }
.thought-container .thought-header {
  display: flex; align-items: center; gap: 8px; font-weight: 600; letter-spacing: 0.02em;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; color: #fff;
}
.thought-container .thought-header .chevron { opacity: 0.8; transition: transform 0.2s ease; }
.thought-container .thought-content {
  display: block; overflow-y: auto; margin-top: 0; padding-top: 0;
  max-height: 3.1em; /* ~2 lines */
  line-height: 1.35;
}
.thought-container .thought-content::-webkit-scrollbar { display: none; }
.thought-container.expanded { max-height: none; overflow: visible; }
.thought-container.expanded .thought-content { max-height: none; }
.thought-container.expanded .chevron { transform: rotate(180deg); }
.stats-container, .final-thoughts-container {
  padding: 8px 0 0 0; margin-top: 8px; border-top: 1px solid var(--border); font-size: 0.85em;
}
.message-footer {
  display: flex; align-items: center; gap: 12px;
  font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px;
  opacity: 0.6; transition: opacity 0.2s; padding: 0 5px;
}
.message:hover .message-footer { opacity: 1; }
.message.user .message-footer { align-self: flex-end; }
.message.assistant .message-footer { align-self: flex-start; }
.message-actions { display: flex; gap: 8px; }
.message-actions button {
  background: none; border: none; color: var(--text-secondary); cursor: pointer;
  font-size: 1.1rem; padding: 2px 4px; border-radius: 4px; transition: all 0.2s;
}
.message-actions button:hover { color: var(--text-primary); background: var(--bg-tertiary); }
.chat-input-container { padding: 20px; background: var(--bg-tertiary); border-top: 1px solid var(--border); }
.chat-input-wrapper { display: flex; gap: 12px; align-items: flex-end; }
.chat-input {
  flex: 1; background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 24px;
  padding: 12px 20px; color: var(--text-primary); font-size: 0.95rem; resize: none;
  outline: none; transition: border-color 0.2s; max-height: 120px; overflow-y: auto;
}
.chat-input:focus { border-color: var(--accent); }
.send-button {
  background: var(--accent); color: white; border: none; border-radius: 50%; width: 44px;
  height: 44px; display: flex; align-items: center; justify-content: center; cursor: pointer;
  transition: all 0.2s; flex-shrink: 0;
}
.send-button:hover:not(:disabled) { background: var(--accent-hover); transform: scale(1.05); }
.send-button:disabled { opacity: 0.5; cursor: not-allowed; }
.stop-button { background: var(--danger); }
.stop-button:hover { background: #dc2626; }
.side-panel {
  width: 320px; background: var(--bg-tertiary); padding: 20px; overflow-y: auto;
  display: flex; flex-direction: column; gap: 24px; transition: all 0.3s ease-in-out;
  flex-shrink: 0;
}
.side-panel.left-panel { border-right: 1px solid var(--border); }
.side-panel.right-panel { border-left: 1px solid var(--border); }
.side-panel.collapsed { width: 0; padding: 20px 0; overflow: hidden; }
.panel-toggle-handle {
  width: 20px; background: var(--bg-tertiary); cursor: pointer; display: flex;
  align-items: center; justify-content: center; color: var(--text-secondary);
  transition: all 0.3s ease-in-out;
}
.panel-toggle-handle:hover { background: var(--bg-secondary); color: var(--text-primary); }
.panel-section { display: flex; flex-direction: column; gap: 12px; }
.panel-title {
  font-size: 0.875rem; font-weight: 600; color: var(--text-secondary);
  text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer;
}
.panel-title::after { content: ' ‚ñº'; font-size: 0.8em; }
.panel-title.collapsed::after { content: ' ‚ñ∫'; }
.action-buttons { display: flex; flex-wrap: wrap; gap: 8px; }
.action-buttons .btn { flex: 1 1 120px; text-align: center;}
.btn {
  background: var(--bg-secondary); border: 1px solid var(--border); color: var(--text-primary);
  padding: 8px 12px; border-radius: 8px; font-size: 0.875rem; cursor: pointer; transition: all 0.2s;
}
.btn:hover { background: var(--accent); border-color: var(--accent); }
.btn.danger:hover { background: var(--danger); border-color: var(--danger); }
.collapsible-content { display: none; padding-top: 10px; border-top: 1px solid var(--border); margin-top: 10px; }
.collapsible-content.show { display: flex; flex-direction: column; gap: 12px; }
.slider-container, .toggle-container, .form-group { display: flex; flex-direction: column; gap: 10px; font-size: 0.875rem; color: var(--text-secondary); }
.toggle-container label { display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
.slider-container label { display: flex; justify-content: space-between; align-items: center; }
.slider-container input[type=range] { width: 100%; }
.side-panel-input, .side-panel-textarea {
  background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 6px;
  color: var(--text-primary); padding: 8px; width: 100%;
}
.side-panel-textarea { resize: vertical; min-height: 80px; }
.responding-indicator { color: var(--text-secondary); font-style: italic; animation: fadeIn 0.5s; }
.responding-indicator .dot { animation: blink 1.4s infinite both; }
.responding-indicator .dot:nth-child(2) { animation-delay: .2s; }
.responding-indicator .dot:nth-child(3) { animation-delay: .4s; }
@keyframes blink { 0%, 80%, 100% { opacity: 0; } 40% { opacity: 1; } }
.modal-backdrop {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7);
  display: none; align-items: center; justify-content: center; z-index: 1000;
}
.modal-content {
  background: var(--bg-secondary); padding: 25px; border-radius: 12px; width: 90%; max-width: 700px;
  border: 1px solid var(--border); box-shadow: var(--shadow); display: flex; flex-direction: column;
  gap: 15px; max-height: 90vh;
}
.modal-body { overflow-y: auto; white-space: pre-wrap; }
.modal-content h2 { font-size: 1.2rem; }
.modal-close-btn { align-self: flex-end; background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; }
.form-group label { font-size: 0.9rem; color: var(--text-secondary); }
.modal-input, .modal-textarea {
  background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px;
  padding: 10px; color: var(--text-primary); font-size: 0.9rem;
}
.modal-textarea { resize: vertical; min-height: 200px; font-family: monospace; }
.modal-footer { display: flex; gap: 10px; justify-content: flex-end; margin-top: 10px; }
.modal-footer .btn-group { display: flex; gap: 10px; flex-grow: 1; }
.icon { width: 20px; height: 20px; fill: currentColor; }
.chat-list { list-style: none; display: flex; flex-direction: column; gap: 8px; }
.chat-list-item {
  padding: 10px; border-radius: 8px; cursor: pointer;
  background: var(--bg-secondary); border: 1px solid transparent; transition: all 0.2s;
  display: flex; justify-content: space-between; align-items: center;
}
.chat-list-item:hover { background: var(--bg-tertiary); border-color: var(--border); }
.chat-list-item.active { background: var(--accent); color: white; border-color: var(--accent); }
.delete-chat-btn {
    font-size: 1.2rem; color: var(--text-secondary); padding: 0 5px; border-radius: 4px;
    line-height: 1; opacity: 0.5; transition: all 0.2s;
}
.chat-list-item:hover .delete-chat-btn { opacity: 1; color: var(--danger); }
.delete-chat-btn:hover { background-color: rgba(255,255,255,0.1); }
#sys-info-content a { color: var(--accent); text-decoration: none; }
#sys-info-content a:hover { text-decoration: underline; }
#changelog-content { font-family: monospace; font-size: 0.85rem; white-space: pre-wrap; max-height: 200px; overflow-y: auto; }
.collapse-handle { display: none; }
@media (max-width: 1024px) {
  .side-panel { position: fixed; top: 0; height: 100%; z-index: 500; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
  .side-panel.left-panel { left: 0; transform: translateX(-100%); }
  .side-panel.left-panel.collapsed { transform: translateX(-100%); }
  .container.left-panel-open .side-panel.left-panel { transform: translateX(0); }
  .side-panel.right-panel { right: 0; transform: translateX(100%); }
  .side-panel.right-panel.collapsed { transform: translateX(100%); }
  .container.right-panel-open .side-panel.right-panel { transform: translateX(0); }
  .panel-toggle-handle { display: none; }
  .chat-header-buttons { display: flex !important; gap: 10px; }
  .collapse-handle { display: block; margin-bottom: 15px; }
}
</style>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js"></script>
</head>
<body>
<div id="app-container" class="container">
  <div id="left-panel-toggle" class="panel-toggle-handle left-handle">‚óÄ</div>
  <div id="left-panel" class="side-panel left-panel collapsed">
    <button class="btn collapse-handle">Zwi≈Ñ &times;</button>
    <div class="panel-section">
      <div class="panel-title">Chats</div>
      <ul id="chat-list" class="chat-list"></ul>
      <div class="form-group" style="margin-top: 15px;">
        <input type="text" id="new-chat-name" class="side-panel-input" placeholder="New chat name...">
        <button id="add-chat-btn" class="btn" style="width:100%; margin-top: 8px;">Create Chat</button>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-title panel-toggle">Persona</div>
      <div class="collapsible-content show">
          <img id="persona-avatar" src="/static/default_avatar.png" style="width:100%; height:auto; aspect-ratio: 1/1; border-radius:12px; object-fit:cover; margin: 0 auto 10px auto; border: 2px solid var(--border);">
          <div style="display:flex; gap: 8px;">
            <select id="side-panel-persona-preset" class="side-panel-input" style="flex:1;"></select>
            <button class="btn" id="side-panel-load-btn">Load</button>
          </div>
          <button class="btn" id="open-persona-modal" style="width:100%; margin-top: 10px;">Full Persona Editor</button>
      </div>
    </div>
  </div>

  <div class="main-panel">
    <div class="chat-header">
      <div class="chat-header-buttons" style="display: none;">
        <button id="mobile-menu-left" class="btn">‚ò∞</button>
      </div>
      <h1 id="chat-title">AI Roleplay</h1>
      <div style="display: flex; align-items: center; gap: 15px;">
        <div class="status">
          <span id="status-text">Disconnected</span>
          <span id="status-dot" class="status-dot"></span>
        </div>
        <div class="chat-header-buttons" style="display: none;">
          <button id="mobile-menu-right" class="btn">‚öô</button>
        </div>
      </div>
    </div>
    <div id="chat-messages" class="chat-messages"></div>
    <div class="chat-input-container">
      <div class="chat-input-wrapper">
        <textarea id="chat-input" class="chat-input" placeholder="Type your message..." rows="1"></textarea>
        <button id="send-btn" class="send-button" disabled>
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:24px; height:24px;"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>
        </button>
        <button id="stop-btn" class="send-button stop-button" style="display: none;">
          <svg class="icon" viewBox="0 0 24 24" fill="currentColor" style="width:24px; height:24px;"><rect x="6" y="6" width="12" height="12" rx="2"/></svg>
        </button>
      </div>
    </div>
  </div>

  <div id="right-panel" class="side-panel right-panel collapsed">
    <button class="btn collapse-handle">Zwi≈Ñ &times;</button>
    <div class="panel-section">
      <div class="panel-title panel-toggle">Quick Actions</div>
      <div class="collapsible-content show">
          <div class="action-buttons">
            <button class="btn" id="reload-chat">Reload</button>
            <button class="btn" id="new-day">New Day</button>
            <button class="btn" id="check-summary">Check Summary</button>
            <button class="btn" id="force-summary-btn">Summarize</button>
            <button class="btn danger" id="clear-memory">Clear Memory</button>
          </div>
          </div>
    </div>
    <div class="panel-section" id="memory-panel" style="display: none;">
      <div class="panel-title panel-toggle">üß† Retrieved Memories</div>
      <div id="memory-content" class="collapsible-content show" style="font-size: 0.8em; max-height: 250px; overflow-y: auto; background: var(--bg-secondary); padding: 10px; border-radius: 6px;"></div>
    </div>
    <div class="panel-section">
      <div class="panel-title panel-toggle">Adv Settings</div>
      <div class="collapsible-content">
          <div class="form-group">
            <label for="model-select">Text Model:</label>
            <select id="model-select" class="side-panel-input"></select>
          </div>
          <div class="form-group">
            <label for="embedding-model-select">Embedding Model:</label>
            <select id="embedding-model-select" class="side-panel-input"></select>
          </div>
          <small style="color: var(--text-secondary); font-size: 0.75rem;">(Models must be loaded in LM Studio to appear here)</small>
          <div class="toggle-container">
            <label><span>Persistent Stats</span><input type="checkbox" id="persistent-stats-toggle"></label>
          </div>
          <div class="toggle-container">
            <label><span>Enable Memory (Embeddings)</span><input type="checkbox" id="enable-memory-toggle" checked></label>
          </div>
          <div class="slider-container">
              <label>Temperature: <span id="temp-value">1.0</span></label>
              <input type="range" id="temperature-slider" min="0.1" max="2.5" step="0.05" value="1.0">
          </div>
          <div class="slider-container">
              <label>Max Tokens: <span id="tokens-value">1024</span></label>
              <input type="range" id="tokens-slider" min="256" max="8192" step="128" value="1024">
          </div>
          <div class="slider-container">
              <label>Thought Ratio: <span id="thought-ratio-value">0.5</span></label>
              <input type="range" id="thought-ratio-slider" min="0.0" max="1.5" step="0.05" value="0.5">
          </div>
          <div class="slider-container">
              <label>Talkativeness: <span id="talkativeness-value">0.5</span></label>
              <input type="range" id="talkativeness-slider" min="0.0" max="1.5" step="0.05" value="0.5">
          </div>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-title panel-toggle">World Events</div>
      <div class="collapsible-content">
        <textarea id="world-event-input" class="side-panel-textarea" placeholder="e.g., The sky suddenly turns crimson."></textarea>
        <div style="display:flex; gap:8px; align-items:center;">
          <select id="event-type-select" class="side-panel-input" style="flex:1;">
            <option value="messages">Msg Count</option>
            <option value="time">Minutes</option>
          </select>
          <input type="number" id="event-value-input" class="side-panel-input" value="3" style="flex:1;">
        </div>
        <button class="btn" id="inject-event-btn">Inject Event</button>
      </div>
    </div>
    <div class="panel-section">
      <div class="panel-title panel-toggle">System Info</div>
      <div class="collapsible-content">
          <div style="font-size: 0.875rem; color: var(--text-secondary);">
            <div style="margin-top: 8px;"><button class="btn" id="test-text-model" style="width: 100%;">Test Selected Text Model</button></div>
            <div style="margin-top: 8px;"><button class="btn" id="test-embed" style="width: 100%;">Test Selected Embedding Model</button></div>
            <div style="margin-top: 8px;"><button class="btn" id="open-sys-info-modal" style="width: 100%;">About This App</button></div>
          </div>
      </div>
    </div>
  </div>
  <div id="right-panel-toggle" class="panel-toggle-handle right-handle">‚ñ∂</div>
</div>

<div id="persona-modal" class="modal-backdrop">
  <div class="modal-content">
    <button id="persona-modal-close" class="modal-close-btn">&times;</button>
    <h2>Persona Editor</h2>
    <div class="modal-body">
        <div class="form-group">
        <label for="persona-prompt">Generate from simple prompt:</label>
        <div style="display:flex; gap: 10px;">
            <input type="text" id="persona-prompt" class="modal-input" placeholder="e.g., a brutal ninja from japan that is vicious">
            <button id="generate-persona-btn" class="btn">Generate</button>
        </div>
        </div>
        <div class="form-group">
        <label for="persona-editor">Persona JSON (edit directly):</label>
        <textarea id="persona-editor" class="modal-textarea"></textarea>
        </div>
    </div>
    <div class="modal-footer">
      <div class="btn-group">
        <select id="saved-personas-list" class="modal-input"></select>
        <button class="btn" id="load-persona-btn">Load</button>
      </div>
      <div class="btn-group">
        <input type="text" id="save-persona-name" class="modal-input" placeholder="New Persona Name">
        <button class="btn" id="save-persona-btn">Save</button>
      </div>
    </div>
  </div>
</div>

<div id="sys-info-modal" class="modal-backdrop">
  <div class="modal-content">
    <button id="sys-info-modal-close" class="modal-close-btn">&times;</button>
    <h2>About This Application</h2>
    <div id="sys-info-content" class="modal-body">
        <p>This is an advanced, self-hosted AI roleplaying chat server.</p>
        <p><strong>Version:</strong> <span id="sys-info-version"></span> | <strong>LLM:</strong> <span id="sys-info-model"></span></p>
        <p><strong>Author:</strong> <a id="sys-info-author-gh" href="https://github.com/wieszjak" target="_blank">WIESZJAK</a></p>
        <div class="panel-title panel-toggle" id="changelog-toggle">Changelog</div>
        <div id="changelog-content" class="collapsible-content"></div>
    </div>
  </div>
</div>

<div id="summary-modal" class="modal-backdrop">
    <div class="modal-content">
      <button id="summary-modal-close" class="modal-close-btn">&times;</button>
      <h2>Last Summary</h2>
      <div id="summary-modal-body" class="modal-body message-body" style="background: rgba(255,255,255,0.05); border-radius: 12px; padding: 15px;">
        <p>No summary available for this chat yet.</p>
      </div>
    </div>
</div>

<script>



'use strict';
// --- State and Constants ---
if (!window.appState) {
    window.appState = {
        ws: null,
        isGenerating: false,
        currentMessageContainer: null,
        fullResponseText: '',
        activeChatId: 'default_chat',
        isInitialized: false,
        isStreamInitialized: false,
        awaitingAssistantTimestamp: false
    };
}
const SETTINGS_KEY = 'aiRoleplaySettings_v3';
const DOM = {
    chatMessages: document.getElementById('chat-messages'),
    chatInput: document.getElementById('chat-input'),
    sendBtn: document.getElementById('send-btn'),
    stopBtn: document.getElementById('stop-btn'),
    statusText: document.getElementById('status-text'),
    statusDot: document.getElementById('status-dot'),
    chatTitle: document.getElementById('chat-title'),
    leftPanel: document.getElementById('left-panel'),
    rightPanel: document.getElementById('right-panel'),
    leftPanelToggle: document.getElementById('left-panel-toggle'),
    rightPanelToggle: document.getElementById('right-panel-toggle'),
    mobileMenuLeft: document.getElementById('mobile-menu-left'),
    mobileMenuRight: document.getElementById('mobile-menu-right'),
    appContainer: document.getElementById('app-container'),
    chatList: document.getElementById('chat-list'),
    newChatName: document.getElementById('new-chat-name'),
    addChatBtn: document.getElementById('add-chat-btn'),
    reloadChatBtn: document.getElementById('reload-chat'),
    newDayBtn: document.getElementById('new-day'),
    checkSummaryBtn: document.getElementById('check-summary'),
    forceSummaryBtn: document.getElementById('force-summary-btn'),
    clearMemoryBtn: document.getElementById('clear-memory'),
    modelSelect: document.getElementById('model-select'),
    embeddingModelSelect: document.getElementById('embedding-model-select'),
    persistentStatsToggle: document.getElementById('persistent-stats-toggle'),
    enableMemoryToggle: document.getElementById('enable-memory-toggle'),
    tempSlider: document.getElementById('temperature-slider'),
    tempValue: document.getElementById('temp-value'),
    tokensSlider: document.getElementById('tokens-slider'),
    tokensValue: document.getElementById('tokens-value'),
    thoughtSlider: document.getElementById('thought-ratio-slider'),
    thoughtValue: document.getElementById('thought-ratio-value'),
    talkSlider: document.getElementById('talkativeness-slider'),
    talkValue: document.getElementById('talkativeness-value'),
    personaAvatar: document.getElementById('persona-avatar'),
    sidePanelPersonaPreset: document.getElementById('side-panel-persona-preset'),
    sidePanelLoadBtn: document.getElementById('side-panel-load-btn'),
    openPersonaModalBtn: document.getElementById('open-persona-modal'),
    worldEventInput: document.getElementById('world-event-input'),
    eventTypeSelect: document.getElementById('event-type-select'),
    eventValueInput: document.getElementById('event-value-input'),
    injectEventBtn: document.getElementById('inject-event-btn'),
    testTextModelBtn: document.getElementById('test-text-model'),
    testEmbedBtn: document.getElementById('test-embed'),
    openSysInfoModalBtn: document.getElementById('open-sys-info-modal'),
    personaModal: document.getElementById('persona-modal'),
    personaModalClose: document.getElementById('persona-modal-close'),
    generatePersonaBtn: document.getElementById('generate-persona-btn'),
    personaPrompt: document.getElementById('persona-prompt'),
    personaEditor: document.getElementById('persona-editor'),
    savedPersonasList: document.getElementById('saved-personas-list'),
    loadPersonaBtn: document.getElementById('load-persona-btn'),
    savePersonaName: document.getElementById('save-persona-name'),
    savePersonaBtn: document.getElementById('save-persona-btn'),
    sysInfoModal: document.getElementById('sys-info-modal'),
    sysInfoModalClose: document.getElementById('sys-info-modal-close'),
    summaryModal: document.getElementById('summary-modal'),
    summaryModalClose: document.getElementById('summary-modal-close'),
    summaryModalBody: document.getElementById('summary-modal-body'),
    memoryPanel: document.getElementById('memory-panel'),
    memoryContent: document.getElementById('memory-content')
};

// --- Core Utility Functions (defined first to prevent ReferenceError) ---
function updateStatus(status) {
  DOM.statusText.textContent = status.charAt(0).toUpperCase() + status.slice(1);
  DOM.statusDot.className = 'status-dot ' + status;
  toggleSendStopButtons(status === 'generating');
}

function toggleSendStopButtons(showStop) {
  DOM.sendBtn.style.display = showStop ? 'none' : 'flex';
  DOM.stopBtn.style.display = showStop ? 'flex' : 'none';
}

function renderMarkdown(text) {
    if (typeof text !== 'string') return '';
    if (window.marked && window.DOMPurify) {
        const rawHtml = marked.parse(text, { gfm: true, breaks: true });
        return DOMPurify.sanitize(rawHtml);
    }
    // Fallback parser for environments without the libraries
    return text
        .replace(/^######\s*(.*)$/gm, '<h6>$1</h6>')
        .replace(/^#####\s*(.*)$/gm, '<h5>$1</h5>')
        .replace(/^####\s*(.*)$/gm, '<h4>$1</h4>')
        .replace(/^###\s*(.*)$/gm, '<h3>$1</h3>')
        .replace(/^##\s*(.*)$/gm, '<h2>$1</h2>')
        .replace(/^#\s*(.*)$/gm, '<h1>$1</h1>')
        .replace(/^\s*[-*]\s+(.*)$/gm, '<ul><li>$1</li></ul>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/\n/g, '<br>');
}

function escapeRegex(text) {
    return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function stripThinkTags(text) {
    if (!text) return '';
    return text
        .replace(/<think\b[^>]*>/gi, '')   // Usu≈Ñ <think> (globalnie, case-insensitive)
        .replace(/<\/think\s*>/gi, '')      // Usu≈Ñ </think>
        .replace(/<BEGIN_THOUGHTS>/gi, '')  // Usu≈Ñ tagi BEGIN je≈õli zosta≈Çy
        .replace(/<\/BEGIN_THOUGHTS>/gi, '')
        .trim();
}

function extractWrappedSection(text, startTag, endTag) {
    if (!text) return { section: '', remaining: text };
    
    const startEsc = escapeRegex(startTag);
    const endEsc = escapeRegex(endTag);
    
    // 1. Kompletny blok
    const completePattern = new RegExp(`${startEsc}([\\s\\S]*?)${endEsc}`, 'i');
    const completeMatch = text.match(completePattern);
    
    if (completeMatch) {
        const section = (completeMatch[1] || '').trim();
        const remaining = (text.slice(0, completeMatch.index) + text.slice(completeMatch.index + completeMatch[0].length)).trim();
        return { section, remaining };
    }
    
    // 2. Strumieniowanie (tylko otwarcie)
    const startPattern = new RegExp(`${startEsc}([\\s\\S]*)`, 'i');
    const startMatch = text.match(startPattern);
    
    if (startMatch) {
        const section = (startMatch[1] || '').trim();
        const remaining = text.slice(0, startMatch.index).trim();
        return { section, remaining };
    }

    return { section: '', remaining: text };
}

function normalizeLabeledSection(text, header) {
    if (!text) return '';
    const trimmed = text.trim();
    const headerToken = `**[[${header}]]**`;
    if (!trimmed.toLowerCase().includes(headerToken.toLowerCase())) {
        return `${headerToken}\n${trimmed}`;
    }
    return trimmed;
}

function extractPrefixedSection(text, label) {
    if (!text) return { section: '', remaining: text };

    const pattern = new RegExp(`^\\s*${label}\\s*:\\s*(.+?)(?:\\n{2,}|\\r?\\n\\r?\\n|$)`, 'is');
    const match = text.match(pattern);
    if (!match) return { section: '', remaining: text };

    const section = (match[1] || '').trim();
    const remaining = (text.slice(0, match.index) + text.slice(match.index + match[0].length)).trim();
    return { section, remaining };
}

function parseFullResponse(fullText) {
    let tempText = fullText || '';
    let thoughts = '', stats = '', finalThoughts = '', cleanContent = '';

    // Funkcja pomocnicza: wycina sekcjƒô i aktualizuje tekst
    const extractAndRemove = (start, end) => {
        const result = extractWrappedSection(tempText, start, end);
        if (result.section) {
            tempText = result.remaining;
            return result.section;
        }
        return null;
    };

    // 1. THOUGHTS: Sprawdzamy oba warianty tag√≥w.
    // Najpierw standardowy <BEGIN_THOUGHTS>
    let th = extractAndRemove('<BEGIN_THOUGHTS>', '</BEGIN_THOUGHTS>');
    
    // Je≈õli nie znaleziono, szukamy <think>. 
    // WA≈ªNE: Robimy to TYLKO je≈õli th jest puste, aby nie nadpisaƒá znaleziska.
    if (!th) {
        th = extractAndRemove('<think>', '</think>');
    }
    
    if (th) thoughts = stripThinkTags(th);

    // 2. STATS
    const st = extractAndRemove('<BEGIN_STATS>', '</BEGIN_STATS>');
    if (st) stats = st;

    // 3. FINAL THOUGHTS
    const fin = extractAndRemove('<BEGIN_FINAL>', '</BEGIN_FINAL>');
    if (fin) finalThoughts = fin;

    // 4. ANSWER
    const ans = extractAndRemove('<BEGIN_ANSWER>', '</BEGIN_ANSWER>');
    if (ans) {
        cleanContent = ans;
    } else {
        // Fallback: To co zosta≈Ço, jest tre≈õciƒÖ
        cleanContent = tempText.trim();
    }

    // Normalizacja nag≈Ç√≥wk√≥w
    if (stats) stats = normalizeLabeledSection(stats, 'Stats');
    if (finalThoughts) finalThoughts = normalizeLabeledSection(finalThoughts, 'Final Thoughts');

    return { content: cleanContent, thoughts, stats, final_thoughts: finalThoughts };
}

function normalizeMessageDataForRender(msgData = {}) {
    const normalized = {
        content: msgData.content || '',
        thoughts: msgData.thoughts || '',
        stats: msgData.stats || '',
        final_thoughts: msgData.final_thoughts || msgData.finalThoughts || ''
    };

    // POPRAWKA: Rozszerzona detekcja znacznik√≥w. 
    // Teraz sprawdzamy te≈º Stats, Final Thoughts oraz tagi XML <BEGIN_...>.
    const structureRegex = /<think\b[^>]*>|\*\*\[\[Thoughts\]\]\*\*|\*\*\[\[Stats\]\]\*\*|\*\*\[\[Final Thoughts\]\]\*\*|<BEGIN_[A-Z]+>/i;
    
    const hasInlineStructuredBlocks = structureRegex.test(normalized.content);

    if (hasInlineStructuredBlocks) {
        const parsed = parseFullResponse(normalized.content);
        // Je≈õli parser co≈õ wyciƒÖgnƒÖ≈Ç, aktualizujemy pola, ale nie nadpisujemy istniejƒÖcych, je≈õli sƒÖ puste w wyniku parsowania
        normalized.content = parsed.content || normalized.content;
        if(parsed.thoughts) normalized.thoughts = parsed.thoughts;
        if(parsed.stats) normalized.stats = parsed.stats;
        if(parsed.final_thoughts) normalized.final_thoughts = parsed.final_thoughts;
    }

    normalized.stats = normalizeLabeledSection(normalized.stats, 'Stats');
    normalized.final_thoughts = normalizeLabeledSection(normalized.final_thoughts, 'Final Thoughts');

    return normalized;
}

function updateOrCreateElement(parent, selector, content, position = 'append') {
    if (!content || content.trim() === '') {
        const el = parent.querySelector(selector);
        if (el) el.style.display = 'none';
        return;
    }
    
    let element = parent.querySelector(selector);
    if (!element) {
        element = document.createElement('div');
        element.className = selector.substring(1); // e.g., '.thought-container' -> 'thought-container'
        if (position === 'prepend') parent.prepend(element);
        else parent.appendChild(element);
    }

    element.style.display = 'block';
    const htmlContent = renderMarkdown(content);

    if (selector === '.thought-container') {
        const wasExpanded = element.classList.contains('expanded');
        if (!element.innerHTML.trim()) {
            element.innerHTML = `
                <div class="thought-header" role="button" aria-expanded="false">
                    <span class="chevron">‚ñº</span>
                    <span>Thoughts</span>
                </div>
                <div class="thought-content"></div>`;
        }

        const contentEl = element.querySelector('.thought-content');
        const headerEl = element.querySelector('.thought-header');
        if (contentEl && contentEl.innerHTML !== htmlContent) {
            contentEl.innerHTML = htmlContent;
        }

        if (contentEl) {
            const autoScroll = !element.classList.contains('expanded');
            if (autoScroll) {
                requestAnimationFrame(() => {
                    contentEl.scrollTop = contentEl.scrollHeight;
                });
            }
        }

        const setExpanded = (expanded) => {
            element.classList.toggle('expanded', expanded);
            if (headerEl) headerEl.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        };
        setExpanded(wasExpanded);

        if (!element.hasToggleListener && headerEl) {
            headerEl.addEventListener('click', (event) => {
                event.stopPropagation();
                const nextState = !element.classList.contains('expanded');
                setExpanded(nextState);
            });
            element.hasToggleListener = true;
        }
    } else {
        if (element.innerHTML !== htmlContent) {
            element.innerHTML = htmlContent;
        }
    }
}

function renderMessage(msgWrapper, msgData) {
    const msgBody = msgWrapper.querySelector('.message-body');
    if (!msgBody) return;
    msgBody.innerHTML = ''; // Clear for final, clean render

    const normalized = normalizeMessageDataForRender(msgData);

    updateOrCreateElement(msgBody, '.thought-container', normalized.thoughts, 'prepend');
    updateOrCreateElement(msgBody, '.message-content', normalized.content, 'append');
    updateOrCreateElement(msgBody, '.stats-container', normalized.stats, 'append');
    updateOrCreateElement(msgBody, '.final-thoughts-container', normalized.final_thoughts, 'append');
}

// --- Main Application Logic ---
function connectWebSocket() {
    return new Promise((resolve, reject) => {
        if (appState.ws && appState.ws.readyState === WebSocket.OPEN) {
            appState.ws.send(JSON.stringify({ type: 'init', chat_id: appState.activeChatId }));
            resolve();
            return;
        }
        if (appState.ws && (appState.ws.readyState === WebSocket.OPEN || appState.ws.readyState === WebSocket.CONNECTING)) {
    try { appState.ws.send(JSON.stringify({ type: 'init', chat_id: (appState.activeChatId || 'default_chat') })); } catch(e){}
} else {
    const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws';
    appState.ws = new WebSocket(wsUrl);
}

        appState.ws.onopen = () => {
            updateStatus('connected');
            DOM.sendBtn.disabled = false;
            appState.ws.send(JSON.stringify({ type: 'init', chat_id: appState.activeChatId }));
            resolve();
        };
        appState.ws.onclose = () => {
            updateStatus('disconnected');
            DOM.sendBtn.disabled = true;
            appState.isGenerating = false;
            setTimeout(connectWebSocket, 3000);
        };
        appState.ws.onerror = (error) => {
            updateStatus('disconnected');
            appState.isGenerating = false;
            console.error("WebSocket Error:", error);
            reject(error);
        };
        appState.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            } catch (e) {
                console.error("Failed to parse WebSocket message:", event.data, e);
            }
        };
    });
}

function handleWebSocketMessage(data) {
    switch (data.type) {
        case 'start': // This is now mainly a server-side confirmation, UI is handled by sendMessage
            appState.isGenerating = true;
            updateStatus('generating');
            appState.fullResponseText = '';
            appState.isStreamInitialized = false;
            appState.awaitingAssistantTimestamp = false;
            if(data.old_ts) {
                document.querySelector(`.message[data-ts="${data.old_ts}"]`)?.remove();
            }
            break;
        case 'partial':
            handlePartialMessage(data.chunk);
            break;
        case 'done':
        case 'stopped':
            appState.isGenerating = false;
            updateStatus('connected');
            appState.awaitingAssistantTimestamp = true;
            // Niekt√≥re dostawcy zwracajƒÖ ko≈Ñcowy fragment tylko w zdarzeniu "done"
            if (typeof data.chunk === 'string' && data.chunk.trim()) {
                appState.fullResponseText += data.chunk;
            }
            // Zapewnienie, ≈ºe zawsze mamy kontener, nawet je≈õli strumie≈Ñ nigdy nie wystartowa≈Ç
            if (!appState.currentMessageContainer) {
                appState.currentMessageContainer = addMessage('assistant');
            }
            
            // UWAGA: Pe≈Çne renderowanie jest teraz celowo przesuniƒôte do 'assistant_ts' 
            // w celu zsynchronizowania z zapisem na dysku.
            
            // U≈ºyj pe≈Çnego tekstu odpowiedzi, kt√≥ry zosta≈Ç zgromadzony podczas strumieniowania.
            if (appState.currentMessageContainer && appState.fullResponseText) {
                // Renderujemy to, co mamy, je≈õli strumie≈Ñ siƒô zatrzyma≈Ç.
                renderMessage(appState.currentMessageContainer, parseFullResponse(appState.fullResponseText));
            }

            if (data.type === 'stopped') {
                // Je≈õli strumie≈Ñ zosta≈Ç zatrzymany rƒôcznie, renderujemy to, co mamy, i czy≈õcimy stan.
                appState.awaitingAssistantTimestamp = false;
                appState.currentMessageContainer = null;
                appState.fullResponseText = ''; 
            }
            break;
        case 'error':
            appState.isGenerating = false;
            updateStatus('connected');
            addMessage('system', `[SERVER ERROR] ${data.message}`);
            break;
        case 'user_ts':
            const el = Array.from(document.querySelectorAll('.message.user')).pop();
            if (el && !el.dataset.ts) {
                el.dataset.ts = data.ts;
                addMessageFooter(el, 'user');
            }
            break;
        case 'assistant_ts':
            if (appState.currentMessageContainer) {
                appState.currentMessageContainer.dataset.ts = data.ts;
                addMessageFooter(appState.currentMessageContainer, 'assistant');
                
                // POPRAWKA: Pobieramy pewnƒÖ, zapisanƒÖ wersjƒô wiadomo≈õci z serwera
                fetch(`/${appState.activeChatId}/messages`)
                    .then(r => r.json())
                    .then(msgs => {
                        const saved = msgs.find(m => m.ts === data.ts);
                        if (saved) renderMessage(appState.currentMessageContainer, saved);
                        else renderMessage(appState.currentMessageContainer, parseFullResponse(appState.fullResponseText));
                    })
                    .catch(() => renderMessage(appState.currentMessageContainer, parseFullResponse(appState.fullResponseText)));
                
                appState.awaitingAssistantTimestamp = false;
                appState.currentMessageContainer = null;
                appState.fullResponseText = '';
            }
            break;
    }
}

function handlePartialMessage(chunk){
  if(!appState.currentMessageContainer) return;
  const body = appState.currentMessageContainer.querySelector('.message-body');
  if(!body) return;
  if(!appState.isStreamInitialized){
    body.querySelector('.responding-indicator')?.remove();
    appState.isStreamInitialized = true;
  }
  appState.fullResponseText += (chunk || '');
  const parsed = parseFullResponse(appState.fullResponseText);
  updateOrCreateElement(body, '.thought-container', parsed.thoughts, 'prepend');
  updateOrCreateElement(body, '.message-content', parsed.content, 'append');
  updateOrCreateElement(body, '.stats-container', parsed.stats, 'append');
  updateOrCreateElement(body, '.final-thoughts-container', parsed.final_thoughts, 'append');
  scrollToBottom();
}



function addMessage(role, content = '', ts = '', thoughts = '', stats = '', final_thoughts = '') {
    const msgWrapper = document.createElement('div');
    msgWrapper.className = `message ${role}`;
    if (ts) msgWrapper.dataset.ts = ts;
    const msgBody = document.createElement('div');
    msgBody.className = 'message-body';
    msgWrapper.appendChild(msgBody);
    
    if (role !== 'assistant' || (role === 'assistant' && !appState.isGenerating)) {
        renderMessage(msgWrapper, { content, thoughts, stats, final_thoughts });
    }

    if (role !== 'system' && ts) {
        addMessageFooter(msgWrapper, role);
    }
    DOM.chatMessages.appendChild(msgWrapper);
    scrollToBottom();
    return msgWrapper;
}

function addMessageFooter(msgWrapper, role) {
    msgWrapper.querySelector('.message-footer')?.remove();
    const footer = document.createElement('div');
    footer.className = 'message-footer';
    const timestamp = document.createElement('span');
    timestamp.className = 'message-timestamp';
    timestamp.textContent = new Date(msgWrapper.dataset.ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    const actionsContainer = document.createElement('div');
    actionsContainer.className = 'message-actions';
    actionsContainer.innerHTML = `<button title="Edit">üìù</button>${role === 'assistant' ? '<button title="Regenerate">üîÑ</button>' : ''}<button title="Delete">üóëÔ∏è</button>`;
    footer.appendChild(timestamp);
    footer.appendChild(actionsContainer);
    msgWrapper.appendChild(footer);
    actionsContainer.querySelector('[title="Delete"]').onclick = () => deleteMessage(msgWrapper.dataset.ts, msgWrapper);
    actionsContainer.querySelector('[title="Edit"]').onclick = () => editMessage(msgWrapper, role);
    if (role === 'assistant') {
        actionsContainer.querySelector('[title="Regenerate"]').onclick = () => regenerateMessage(msgWrapper.dataset.ts);
    }
}

async function deleteMessage(ts, element) {
  if (!ts) return;
  if (confirm('Delete this message?')) {
    await api(`/${appState.activeChatId}/delete_message`, 'POST', { ts });
    element.remove();
  }
}

function editMessage(msgWrapper, role) {
    const msgBody = msgWrapper.querySelector('.message-body');
    if (!msgBody || msgBody.querySelector('textarea')) return;
    const getTextFromContainer = (selector) => {
        const el = msgWrapper.querySelector(selector);
        if (!el || el.style.display === 'none') return '';
        const tempDiv = document.createElement('div');
        const contentSource = el.querySelector('.thought-content') || el;
        tempDiv.innerHTML = contentSource.innerHTML.replace(/<br\s*[\/]?>/gi, "\n");
        return tempDiv.textContent || tempDiv.innerText || "";
    };
    const thoughts = getTextFromContainer('.thought-container');
    const content = getTextFromContainer('.message-content');
    const stats = getTextFromContainer('.stats-container');
    const finalThoughts = getTextFromContainer('.final-thoughts-container');
    let fullRawText = '';
    if (thoughts) fullRawText += `<think>${thoughts.trim()}</think>\n\n`;
    fullRawText += content.trim();
    if (stats) fullRawText += `\n\n${stats.trim()}`;
    if (finalThoughts) fullRawText += `\n\n${finalThoughts.trim()}`;
    const originalHTML = msgBody.innerHTML;
    const editor = document.createElement('textarea');
    editor.className = 'chat-input';
    editor.style.width = '100%';
    editor.value = fullRawText.trim();
    const btnContainer = document.createElement('div');
    btnContainer.style.marginTop = '10px'; btnContainer.style.display = 'flex'; btnContainer.style.gap = '8px';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'btn'; saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn danger'; cancelBtn.textContent = 'Cancel';
    btnContainer.appendChild(saveBtn); btnContainer.appendChild(cancelBtn);
    msgBody.innerHTML = ''; msgBody.appendChild(editor); msgBody.appendChild(btnContainer);
    editor.focus(); editor.style.height = 'auto'; editor.style.height = `${editor.scrollHeight}px`;
    cancelBtn.onclick = () => { msgBody.innerHTML = originalHTML; };
    saveBtn.onclick = async () => {
        const newRawContent = editor.value;
        const result = await api(`/${appState.activeChatId}/edit_message`, 'POST', { ts: msgWrapper.dataset.ts, raw_content: newRawContent });
        renderMessage(msgWrapper, result.updated_message);
        addMessageFooter(msgWrapper, role);
    };
}

async function regenerateMessage(ts) {
    if (!ts || appState.isGenerating) return;
    if (!confirm('Regenerate this response? The current one will be deleted.')) return;
    appState.ws.send(JSON.stringify({ type: 'regenerate', ts, chat_id: appState.activeChatId, settings: getSettings() }));
    // Immediately show visual feedback for regeneration
    appState.isGenerating = true;
    updateStatus('generating');
    const oldMessage = document.querySelector(`.message[data-ts="${ts}"]`);
    if(oldMessage) {
        appState.currentMessageContainer = oldMessage;
        const body = oldMessage.querySelector('.message-body');
        if(body) body.innerHTML = '<div class="responding-indicator"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></div>';
    }
}

function getSettings() {
    return {
      model: DOM.modelSelect.value,
      embedding_model: DOM.embeddingModelSelect.value,
      temperature: parseFloat(DOM.tempSlider.value),
      max_tokens: parseInt(DOM.tokensSlider.value),
      thought_ratio: parseFloat(DOM.thoughtSlider.value),
      talkativeness: parseFloat(DOM.talkSlider.value),
      persistent_stats: DOM.persistentStatsToggle.checked,
      enable_memory: DOM.enableMemoryToggle.checked,
    };
}

function saveSettings() {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(getSettings()));
}

function loadSettings() {
    const savedSettings = localStorage.getItem(SETTINGS_KEY);
    if (savedSettings) {
        try {
            const settings = JSON.parse(savedSettings);
            if(settings.model) DOM.modelSelect.value = settings.model;
            if(settings.embedding_model) DOM.embeddingModelSelect.value = settings.embedding_model;
            DOM.tempSlider.value = settings.temperature || 1.0;
            DOM.tokensSlider.value = settings.max_tokens || 1024;
            DOM.thoughtSlider.value = settings.thought_ratio || 0.5;
            DOM.talkSlider.value = settings.talkativeness || 0.5;
            DOM.persistentStatsToggle.checked = settings.persistent_stats === true;
            DOM.enableMemoryToggle.checked = settings.enable_memory !== false;
            DOM.tempValue.textContent = DOM.tempSlider.value;
            DOM.tokensValue.textContent = DOM.tokensSlider.value;
            DOM.thoughtValue.textContent = DOM.thoughtSlider.value;
            DOM.talkValue.textContent = DOM.talkSlider.value;
        } catch (e) { console.error("Failed to load settings", e); }
    }
}

function scrollToBottom() {
    setTimeout(() => {
        DOM.chatMessages.scrollTo({ top: DOM.chatMessages.scrollHeight, behavior: 'smooth' });
    }, 100);
}

async function sendMessage() {
    const message = DOM.chatInput.value.trim();
    if (!message || appState.isGenerating) return;
    appState.fullResponseText = '';
    appState.isStreamInitialized = false;
    DOM.memoryPanel.style.display = 'none';
    DOM.memoryContent.innerHTML = '';
    DOM.chatInput.value = '';
    DOM.chatInput.style.height = 'auto';
    addMessage('user', message, new Date().toISOString());
    try {
        await connectWebSocket();
        appState.ws.send(JSON.stringify({ type: 'message', message, settings: getSettings(), chat_id: appState.activeChatId }));
        // Start "responding" animation immediately for better UX
        appState.isGenerating = true;
        updateStatus('generating');
        appState.currentMessageContainer = addMessage('assistant');
        const body = appState.currentMessageContainer.querySelector('.message-body');
        // Show a minimal animated placeholder instead of the full template
        if (body) {
            body.innerHTML = '<div class="responding-indicator generating-text">Generating<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></div>';
        }
    } catch (error) {
        addMessage('system', '[ERROR] Connection failed. Please check the server.');
    }
}

function stopGeneration() {
  if (appState.ws && appState.ws.readyState === WebSocket.OPEN && appState.isGenerating) {
    appState.ws.send(JSON.stringify({ type: 'stop', chat_id: appState.activeChatId }));
  }
}

async function api(path, method = 'GET', body = null) {
  try {
    const opts = { method };
    if (body) {
        opts.headers = { 'Content-Type': 'application/json' };
        opts.body = JSON.stringify(body);
    }
    const response = await fetch(path, opts);
    const contentType = response.headers.get("content-type");
    const isJson = contentType && contentType.includes("application/json");
    if (!response.ok) {
        const errorData = isJson ? await response.json() : await response.text();
        const errorText = isJson ? errorData.error || JSON.stringify(errorData) : errorData;
        const errorMsg = `[API ERROR] ${response.status}: ${errorText}`;
        addMessage('system', errorMsg);
        console.error("API Error Response:", errorData);
        throw new Error(`API Error: ${response.status} ${errorText}`);
    }
    return isJson ? await response.json() : await response.text();
  } catch (error) {
      console.error("API call failed:", error);
      addMessage('system', `[API ERROR] Failed to fetch from ${path}. Check server console & .env config.`);
      throw error;
  }
}

async function clearMemory() {
  if (!confirm('Clear all memory for this chat? This deletes conversation history, summaries, stats and events.')) return;
  await api(`/${appState.activeChatId}/clear_memory`, 'POST');
  await reloadChat();
}

async function testEmbeddings() {
    const selectedModel = DOM.embeddingModelSelect.value;
    if (!selectedModel) {
        alert("Please select an embedding model to test.");
        return;
    }
    addMessage('system', `Testing embedding model: ${selectedModel}...`);
    try {
        const res = await api('/test_embeddings', 'POST', { model: selectedModel });
        addMessage('system', res.success ? `‚úÖ Embedding test successful!` : `‚ùå Embedding test failed: ${res.error}`);
    } catch(e) {
        console.error("Failed to test embeddings:", e);
    }
}

async function loadAvailableModels() {
    try {
        const data = await api('/models');
        DOM.modelSelect.innerHTML = '';
        DOM.embeddingModelSelect.innerHTML = '';
        if (data.models && data.models.length > 0) {
            data.models.forEach(modelId => {
                const option = document.createElement('option');
                option.value = modelId;
                option.textContent = modelId;
                DOM.modelSelect.appendChild(option.cloneNode(true));
                DOM.embeddingModelSelect.appendChild(option);
            });
        } else {
             const errorHtml = '<option value="">No models found</option>';
             DOM.modelSelect.innerHTML = errorHtml;
             DOM.embeddingModelSelect.innerHTML = errorHtml;
        }
    } catch (e) {
        const errorHtml = '<option value="">Error loading models</option>';
        DOM.modelSelect.innerHTML = errorHtml;
        DOM.embeddingModelSelect.innerHTML = errorHtml;
    }
    loadSettings();
}

function setupPanelToggles() {
    document.querySelectorAll('.panel-toggle').forEach(toggle => {
        toggle.addEventListener('click', (e) => {
            const content = e.target.nextElementSibling;
            if (content && content.classList.contains('collapsible-content')) {
                content.classList.toggle('show');
                e.target.classList.toggle('collapsed');
            }
        });
    });
    const toggleLogic = (panel, container, className) => {
        const isOpening = !container.classList.contains(className);
        const otherPanelClass = className === 'left-panel-open' ? 'right-panel-open' : 'left-panel-open';
        if (isOpening && window.innerWidth <= 1024) {
            container.classList.remove(otherPanelClass);
            if(otherPanelClass === 'left-panel-open') DOM.leftPanel.classList.add('collapsed');
            else DOM.rightPanel.classList.add('collapsed');
        }
        panel.classList.toggle('collapsed');
        container.classList.toggle(className);
    };
    DOM.leftPanelToggle.addEventListener('click', () => toggleLogic(DOM.leftPanel, DOM.appContainer, 'left-panel-open'));
    DOM.rightPanelToggle.addEventListener('click', () => toggleLogic(DOM.rightPanel, DOM.appContainer, 'right-panel-open'));
    DOM.mobileMenuLeft.addEventListener('click', () => toggleLogic(DOM.leftPanel, DOM.appContainer, 'left-panel-open'));
    DOM.mobileMenuRight.addEventListener('click', () => toggleLogic(DOM.rightPanel, DOM.appContainer, 'right-panel-open'));
    document.querySelectorAll('.collapse-handle').forEach(btn => {
        btn.addEventListener('click', (e) => {
            const panel = e.target.closest('.side-panel');
            if (panel.id === 'left-panel') DOM.appContainer.classList.remove('left-panel-open');
            else if (panel.id === 'right-panel') DOM.appContainer.classList.remove('right-panel-open');
            panel.classList.add('collapsed');
        });
    });
}
function autoResizeTextarea(el) {
    if (!el) return;
    el.style.height = 'auto';
    el.style.height = Math.min(el.scrollHeight, 240) + 'px';
}

async function reloadChat() {
    if (!appState.activeChatId) return;
    try {
        const messages = await api(`/${appState.activeChatId}/messages`);
        DOM.chatMessages.innerHTML = '';
        (messages || []).forEach(msg => {
            if (!msg) return;
            const finalThoughts = msg.final_thoughts || msg.finalThoughts || '';
            addMessage(
                msg.role || 'assistant',
                msg.content || '',
                msg.ts,
                msg.thoughts || '',
                msg.stats || '',
                finalThoughts
            );
        });
        scrollToBottom();
    } catch (error) {
        console.error('Failed to reload chat history:', error);
        addMessage('system', '[ERROR] Failed to load chat history.');
    }
}

async function loadSavedPersonasIntoSelect(selectElement) {
    if (!selectElement) return;
    try {
        const personas = await api('/personas');
        selectElement.innerHTML = '';
        if (personas && personas.length) {
            personas.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                selectElement.appendChild(option);
            });
        } else {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No saved personas';
            selectElement.appendChild(option);
        }
    } catch (error) {
        console.error('Failed to load saved personas:', error);
        selectElement.innerHTML = '<option value="">Error loading personas</option>';
    }
}

async function refreshPersonaLists() {
    await loadSavedPersonasIntoSelect(DOM.savedPersonasList);
    await loadSavedPersonasIntoSelect(DOM.sidePanelPersonaPreset);
}

async function refreshActivePersona() {
    try {
        const persona = await api(`/${appState.activeChatId}/persona`);
        DOM.personaEditor.value = JSON.stringify(persona, null, 2);
        DOM.personaAvatar.src = `/static/${persona.avatar || 'default_avatar.png'}`;
        return persona;
    } catch (error) {
        console.error('Failed to load active persona:', error);
        addMessage('system', '[ERROR] Unable to load the active persona.');
        return null;
    }
}
async function loadAndActivatePersona(name) {
    if (!name) {
        alert('Please select a persona to load.');
        return;
    }
    try {
        const persona = await api(`/personas/${encodeURIComponent(name)}`);
        await api(`/${appState.activeChatId}/persona`, 'POST', persona);
        DOM.personaEditor.value = JSON.stringify(persona, null, 2);
        DOM.personaAvatar.src = `/static/${persona.avatar || 'default_avatar.png'}`;
        addMessage('system', `Persona "${name}" loaded for this chat.`);
    } catch (error) {
        console.error('Failed to load persona:', error);
        alert('Failed to load persona. Please check the server logs.');
    }
}

async function generatePersonaFromPrompt() {
    const prompt = DOM.personaPrompt.value.trim();
    if (!prompt) {
        alert('Please provide a short description to generate a persona.');
        return;
    }
    DOM.generatePersonaBtn.disabled = true;
    DOM.generatePersonaBtn.textContent = 'Generating...';
    try {
        const result = await api('/generate_persona', 'POST', { description: prompt });
        if (result && result.persona) {
            DOM.personaEditor.value = JSON.stringify(result.persona, null, 2);
            DOM.personaAvatar.src = `/static/${result.persona.avatar || 'default_avatar.png'}`;
        }
    } catch (error) {
        console.error('Failed to generate persona:', error);
        alert('Failed to generate persona. Please try again.');
    } finally {
        DOM.generatePersonaBtn.textContent = 'Generate';
        DOM.generatePersonaBtn.disabled = false;
    }
}

async function savePersona() {
    const name = DOM.savePersonaName.value.trim();
    if (!name) {
        alert('Please enter a name to save the persona.');
        return;
    }
    let persona;
    try {
        persona = JSON.parse(DOM.personaEditor.value || '{}');
    } catch (error) {
        alert('Persona JSON is invalid. Please correct it before saving.');
        return;
    }
    try {
        await api(`/personas/${encodeURIComponent(name)}`, 'POST', persona);
        await refreshPersonaLists();
        DOM.savePersonaName.value = '';
        addMessage('system', `Persona "${name}" saved.`);
    } catch (error) {
        console.error('Failed to save persona:', error);
        alert('Failed to save persona.');
    }
}

async function injectWorldEvent() {
    const eventText = DOM.worldEventInput.value.trim();
    if (!eventText) {
        alert('Please describe the world event before injecting it.');
        return;
    }
    try {
        await api(`/${appState.activeChatId}/inject_event`, 'POST', {
            event: eventText,
            type: DOM.eventTypeSelect.value,
            value: parseInt(DOM.eventValueInput.value, 10)
        });
        DOM.worldEventInput.value = '';
        addMessage('system', `[WORLD EVENT INJECTED] ${eventText}`);
    } catch (error) {
        console.error('Failed to inject world event:', error);
        alert('Failed to inject world event.');
    }
}

async function markNewDay() {
    try {
        const response = await api(`/${appState.activeChatId}/new_day`, 'POST');
        if (response.marker) {
            addMessage('system', response.marker);
        }
        if (response.summary) {
            addMessage('system', `Summary Generated:\n${response.summary}`);
        }
        await reloadChat();
    } catch (error) {
        console.error('Failed to mark a new day:', error);
        alert('Failed to mark a new day.');
    }
}

async function checkSummary() {
    try {
        const result = await api(`/${appState.activeChatId}/last_summary`);
        const summary = result && result.summary ? result.summary.trim() : '';
        DOM.summaryModalBody.textContent = summary || 'No summary available yet.';
        DOM.summaryModal.style.display = 'flex';
    } catch (error) {
        console.error('Failed to fetch last summary:', error);
        alert('Failed to fetch the last summary.');
    }
}

async function testTextModel() {
    const selectedModel = DOM.modelSelect.value;
    if (!selectedModel) {
        alert('Please select a text model to test.');
        return;
    }
    addMessage('system', `Testing text model: ${selectedModel}...`);
    try {
        const res = await api('/test_text_model', 'POST', { model: selectedModel });
        addMessage('system', res.success ? '‚úÖ Text model test successful!' : `‚ùå Text model test failed: ${res.error}`);
    } catch (error) {
        console.error('Failed to test text model:', error);
    }
}

function openModal(modal) {
    if (modal) modal.style.display = 'flex';
}

function closeModal(modal) {
    if (modal) modal.style.display = 'none';
}

function setupEventListeners() {
    DOM.sendBtn.addEventListener('click', sendMessage);
    DOM.stopBtn.addEventListener('click', stopGeneration);

    DOM.chatInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });
    DOM.chatInput.addEventListener('input', () => {
        const hasText = DOM.chatInput.value.trim().length > 0;
        DOM.sendBtn.disabled = !hasText || appState.isGenerating;
        autoResizeTextarea(DOM.chatInput);
    });

    DOM.addChatBtn.addEventListener('click', async () => {
        const name = DOM.newChatName.value.trim();
        if (!name) {
            alert('Please enter a chat name.');
            return;
        }
        try {
            const res = await api('/chats/create', 'POST', { name });
            DOM.newChatName.value = '';
            await loadChatList();
            if (res && res.chat_id) {
                await switchChat(res.chat_id);
            }
        } catch (error) {
            console.error('Failed to create chat:', error);
            alert('Failed to create chat.');
        }
    });

    DOM.reloadChatBtn.addEventListener('click', reloadChat);
    DOM.clearMemoryBtn.addEventListener('click', clearMemory);
    DOM.newDayBtn.addEventListener('click', markNewDay);
    DOM.checkSummaryBtn.addEventListener('click', checkSummary);
    DOM.forceSummaryBtn.addEventListener('click', forceSummarize);

    DOM.injectEventBtn.addEventListener('click', injectWorldEvent);

    DOM.testTextModelBtn.addEventListener('click', testTextModel);
    DOM.testEmbedBtn.addEventListener('click', testEmbeddings);

    DOM.openPersonaModalBtn.addEventListener('click', async () => {
        openModal(DOM.personaModal);
        await refreshPersonaLists();
    });
    DOM.personaModalClose.addEventListener('click', () => closeModal(DOM.personaModal));

    DOM.sidePanelLoadBtn.addEventListener('click', () => loadAndActivatePersona(DOM.sidePanelPersonaPreset.value));
    DOM.loadPersonaBtn.addEventListener('click', () => loadAndActivatePersona(DOM.savedPersonasList.value));
    DOM.generatePersonaBtn.addEventListener('click', generatePersonaFromPrompt);
    DOM.savePersonaBtn.addEventListener('click', savePersona);

    DOM.openSysInfoModalBtn.addEventListener('click', async () => {
        openModal(DOM.sysInfoModal);
        try {
            const info = await api('/system_info');
            const versionEl = document.getElementById('sys-info-version');
            const modelEl = document.getElementById('sys-info-model');
            if (versionEl) versionEl.textContent = info.version || 'unknown';
            if (modelEl) modelEl.textContent = info.model_name || 'unknown';
        } catch (error) {
            console.error('Failed to fetch system info:', error);
        }
    });
    DOM.sysInfoModalClose.addEventListener('click', () => closeModal(DOM.sysInfoModal));

    DOM.summaryModalClose.addEventListener('click', () => closeModal(DOM.summaryModal));

    const settingsControls = [
        DOM.modelSelect,
        DOM.embeddingModelSelect,
        DOM.tempSlider,
        DOM.tokensSlider,
        DOM.thoughtSlider,
        DOM.talkSlider,
        DOM.persistentStatsToggle,
        DOM.enableMemoryToggle
    ];
    const sliderLabels = {
        [DOM.tempSlider.id]: DOM.tempValue,
        [DOM.tokensSlider.id]: DOM.tokensValue,
        [DOM.thoughtSlider.id]: DOM.thoughtValue,
        [DOM.talkSlider.id]: DOM.talkValue
    };
    settingsControls.forEach(control => {
        control.addEventListener('input', (event) => {
            if (event.target.type === 'range' && sliderLabels[event.target.id]) {
                sliderLabels[event.target.id].textContent = event.target.value;
            }
            saveSettings();
        });
    });
    autoResizeTextarea(DOM.chatInput);
    DOM.chatInput.dispatchEvent(new Event('input'));
}

async function loadChatList() {
    const chats = await api('/chats');
    DOM.chatList.innerHTML = '';
    if (chats.length === 0) {
        await api('/chats/create', 'POST', { name: 'default_chat' });
        return loadChatList();
    }
    chats.forEach(chatId => {
        const li = document.createElement('li');
        li.className = 'chat-list-item'; li.dataset.chatId = chatId;
        const nameSpan = document.createElement('span');
        nameSpan.textContent = chatId; nameSpan.style.flexGrow = '1'; nameSpan.style.overflow = 'hidden'; nameSpan.style.textOverflow = 'ellipsis';
        const deleteBtn = document.createElement('span');
        deleteBtn.className = 'delete-chat-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.title = `Delete chat "${chatId}"`;
        li.appendChild(nameSpan); li.appendChild(deleteBtn);
        if (chatId === appState.activeChatId) li.classList.add('active');
        li.addEventListener('click', async (e) => {
            if (e.target !== deleteBtn) {
                try {
                    await switchChat(chatId);
                } catch (error) {
                    console.error('Failed to switch chat:', error);
                }
            }
        });
        deleteBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            try {
                await deleteChat(chatId);
            } catch (error) {
                console.error('Failed to delete chat:', error);
            }
        });
        DOM.chatList.appendChild(li);
    });
}

async function deleteChat(chatId) {
    if (appState.isGenerating) { alert("Cannot delete a chat while a response is being generated."); return; }
    if (!confirm(`Are you sure you want to permanently delete the chat "${chatId}"? This cannot be undone.`)) return;
    await api(`/chats/${chatId}`, 'DELETE');
    if (appState.activeChatId === chatId) {
        const chats = await api('/chats');
        const newActiveChat = chats.length > 0 ? chats[0] : 'default_chat';
        await switchChat(newActiveChat);
    }
    await loadChatList();
}

async function switchChat(chatId) {
    if (!chatId) return;
    if (appState.activeChatId === chatId && appState.ws && appState.ws.readyState === WebSocket.OPEN) return;
    appState.activeChatId = chatId;
    DOM.chatTitle.textContent = `Chat: ${chatId}`;
    console.log(`Switching to chat: ${appState.activeChatId}`);
    document.querySelectorAll('.chat-list-item.active').forEach(el => el.classList.remove('active'));
    document.querySelector(`.chat-list-item[data-chat-id="${chatId}"]`)?.classList.add('active');
    appState.isGenerating = false;
    stopGeneration();
    await connectWebSocket();
    await reloadChat();
    await refreshActivePersona();
    DOM.chatInput.value = '';
    DOM.chatInput.dispatchEvent(new Event('input'));
}

async function forceSummarize() {
    addMessage('system', 'Generating summary using LLM...');
    const response = await api(`/${appState.activeChatId}/force_summarize`, 'POST');
    addMessage('system', `Summary Generated:\n${response.summary}`);
}

async function initializeApp() {
    if (window.appState.isInitialized) return;
    window.appState.isInitialized = true;
    try {
        setupEventListeners();
        setupPanelToggles();
        await loadAvailableModels();
        await loadChatList();
        if (!document.querySelector('.chat-list-item.active')) {
            const firstChat = document.querySelector('.chat-list-item');
            appState.activeChatId = firstChat ? firstChat.dataset.chatId : 'default_chat';
            firstChat?.classList.add('active');
        }
        DOM.chatTitle.textContent = `Chat: ${appState.activeChatId}`;
        DOM.persistentStatsToggle.checked = __PERSISTENT_STATS_ENABLED__;
        await connectWebSocket();
        await reloadChat();
        await refreshPersonaLists();
        await refreshActivePersona();
    } catch (error) {
        console.error("Initialization failed:", error);
        addMessage('system', 'A critical error occurred during initialization. Some UI elements may not work. Please check the browser console (F12) for details.');
    }
}

document.addEventListener('DOMContentLoaded', initializeApp);



</script>
</body>
</html>
